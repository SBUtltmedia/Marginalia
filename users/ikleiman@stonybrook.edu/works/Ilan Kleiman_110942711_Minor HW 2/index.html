<table><tr><td><p>Ilan Kleiman</p></td><td><p>Minor Homework 2</p></td><td><p>October 17<sup>th</sup>, 2019</p></td></tr><tr><td><p>110942711</p></td><td></td><td><p>CSE 337</p></td></tr></table><ol><li>Matching with [^O]*o+<ol><li>balloo</li><li>no match</li><li>booksto</li><li>“Loo</li><li>PoolRo</li></ol></li><li>^((01|03|05|07|08|10|12)\/((0[1-9])|(1)([0-9])|(30|31))\/(19[0-9]{2}|20[0-9]{2})|(04|06|09|11)\/((0[1-9])|(1)([0-9])|30)\/(19[0-9]{2}|20[0-9]{2})|(02)\/((0[1-9])|(1)([0-9])|(2[0-8]))\/(19[0-9]{2}|20[0-9]{2}))$</li><li>^\d*[0|2|4|6|8]\-\d{3}\-\d*[1|3|5|7|9]$</li><li>^(0|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.(0|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.(0|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.(0|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$</li><li>Regex descriptions<ol><li>/&quot;([^&quot;]*)&quot;/<ol><li>&quot;<ol><li>Matches for a quotation mark.</li></ol></li><li>([^&quot;]*)<ol><li>Matches for a group, with:<ol><li>Zero or more of any character that isn’t a quotation mark.</li></ol></li></ol></li><li>&quot;<ol><li>Matches for a quotation mark.</li></ol></li></ol></li></ol></li></ol><p>Generally, the regex described above will match the contents of a quote, and place the string inside a group (not including the quotes).</p><p><em>Example</em>: &quot;Hello World!&quot;</p><ul><li><ol><li>/[-+]?\d+(\.\d*)?F\b/<ol><li> [-+]?<ol><li>Individually matches either a negative ‘-‘ or positive ‘+’ sign; once or no times at all.</li></ol></li><li>\d+<ol><li>Matches for any number of digits at least once.</li></ol></li><li>(\.\d*)?<ol><li>Matches a period/decimal ‘.’ then any number of digits or no digits at all; once or no times at all. This matching is enclosed in a grouping.</li></ol></li><li>F<ol><li>Matches for the letter ‘F’ once.</li></ol></li><li>\b<ol><li>Matches for any word boundary once. Such as a new line or empty space…</li></ol></li></ol></li></ol></li></ul><p>Generally, the regex described above will match a “float” decimal number. Or a string representing the temperature in Fahrenheit.</p><p><em>Example</em>: 123.5F</p><ul><li><ol><li>/(\D{2,}).*\[\1\]/<ol><li>(\D{2,})<ol><li>Matches for anything that’s not a digit 2 or more times, and places them into a group.</li></ol></li><li>.*<ol><li>Matches for any character at all, any number of times or none at all.</li></ol></li><li>\[\1\]<ol><li>Matches for brackets […] with the string inside being at least the first two characters of which was matched in part i.</li></ol></li></ol></li></ol></li></ul><p>Generally, the regex described above will match for a string whose first two characters are not digits, then followed by any character, with at least the first two character of the original string in brackets.</p><p><em>Example</em>: array[ar] </p><ul><li><ol><li>/((.*?)\d)\s\2/<ol><li>(<ol><li>Begin of group 1.</li></ol></li><li>(.*?)<ol><li>Match for any character 0 or more times, match the least amount of times possible. Group into 2.</li></ol></li><li>\d<ol><li>Match for any digit once. </li></ol></li><li>)<ol><li>End of group 1.</li></ol></li><li>\s<ol><li>Match for any whitespace</li></ol></li><li>\2<ol><li>Match for what was originally matched into group 2.</li></ol></li></ol></li></ol></li></ul><p>Generally, the regex described above, will match for the least amount of repetitions of anything, then again attempt to match it after a whitespace. </p><p><em>Example</em>: 000 00</p><ul><li><ol><li>/^[0-9]+\/\d+([+\-*\/]\=|([+]{2}|[-]{2}));$/<ol><li>^<ol><li>Beginning of the string</li></ol></li><li>[0-9]+<ol><li>Match for any digit, matches at least for one digit, up to the most it can.</li></ol></li><li>\/<ol><li>Match for ‘/’.</li></ol></li><li>\d+<ol><li>Match for any digit, matches at least for one digit, up to the most it can.</li></ol></li><li>( <ol><li>Begin of group 1.</li></ol></li><li>[+\-*\/]<ol><li>Match for any of the characters: ‘+’, ‘-‘, ‘*’, ‘/’.</li></ol></li><li>\=<ol><li>Match for ‘=’</li></ol></li><li>|<ol><li>Or, match either since the start of group 1 until now, or for the next symbols until end of group 1. </li></ol></li><li>(<ol><li>Begin of group 2.</li></ol></li><li>[+]{2}|[-]{2}<ol><li>Match for the character ‘+’ twice.</li><li>OR</li><li>Match for the character ‘-‘ twice.</li></ol></li><li>)<ol><li>End of group 2.</li></ol></li><li>)<ol><li>End of group 1.</li></ol></li><li>;<ol><li>Match for semicolon.</li></ol></li><li>$<ol><li>Match for end of string.</li></ol></li></ol></li></ol></li></ul><p>Generally, the regex above matches for a number then an arithmetic operation to perform on itself, then ending in a semicolon.</p><p><em>Example</em>: 45/31++;</p>